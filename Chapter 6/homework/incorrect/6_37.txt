配列が1ブロック大きいだけで、cache indexが大きく変わる

C = 4 KB
S = 4096 / 16 = 256
B = 16 bytes
E = 1

sumA
N = 60 array[60][60]
total size 4 * 60 * 60 = 14400 = 16(3840)
4000アドレスを超過する場合 14400 / 4000 = 3.6 = 4 でmodする

total read 60 * 60 = 3600
3600 / 4 = 900
900 / 3600 = 1/4

N = 64 array[64][64]
total size 4 * 64 * 64 = 16384 = 16(4096)
4000アドレスを超過する場合 16384 / 4000 = 4.096 = 5 でmodする

total read 64 * 64 = 4096
4096 / 4 = 1024
1024 / 4096 = 1/4

answer
sumB

N = 64 array[64][64]
total size 4 * 64 * 64 = 16384 = 16(4096)
a[0][0] setindex 0
a[1][0] setindex 16
a[2][0] setindex 32
a[3][0] setindex 48
...
a[63][0] setindex 1008 = 1008 % 256 = 240
0, 16, 32, 48, ..., 240, 0, ..., 240, 0, ..., 240;(4次0~240)
A. 1

N = 60 array[60][60]

a[0][0] setindex 0
a[1][0] setindex 15
a[2][0] setindex 30
a[3][0] setindex 45
...
a[59][0] setindex 944 = 944 % 256 = 176

0, 15, 30, ..., 225, 240, 255, (i: 0～17);
270	% 256	, 
14			, 29, ..., 254, (i: 18～34);
13, 28, ..., 253, (i: 35～51);
12, 27, ..., 117; (i: 52～59);

N = 64だと、16個インデックスがあり、totalインデックスが256なので割り切れてしまうので同じキャッシュ数列になってしまうため。前回のcacheが存在しなくなる。

sumC
N = 64 array[64][64]
a[0][0] 0
a[1][0] 16
a[0][1] 0
a[1][1] 16

total 30 * 30 * 4 = 3600
1800 / 3600 = 1/2

N = 60 array[60][60]
a[0][0] 0
a[1][0] 15
a[0][1] 0
a[1][1] 15

a[2][0] 30
a[3][0] 45
a[2][1] 30
a[3][1] 45

indexが被らないので1/2 * 1/2 = 1/4

...
a[0][2] 0
a[1][2] 15
a[0][3] 0
a[1][3] 15



total 30 * 30 * 4 = 3600
1800 / 3600 = 1/2


